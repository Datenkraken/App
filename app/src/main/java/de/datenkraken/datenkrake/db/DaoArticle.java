package de.datenkraken.datenkrake.db;

import android.net.Uri;

import androidx.lifecycle.LiveData;
import androidx.lifecycle.Transformations;
import androidx.room.Dao;
import androidx.room.Delete;
import androidx.room.Insert;
import androidx.room.OnConflictStrategy;
import androidx.room.Query;
import androidx.room.Transaction;

import de.datenkraken.datenkrake.model.Article;
import de.datenkraken.datenkrake.model.Source;

import java.net.URL;
import java.util.ArrayList;
import java.util.Date;
import java.util.HashSet;
import java.util.List;
import java.util.Set;

import timber.log.Timber;


/**
 * Dao for {@link Article}. <br>
 * Will be decorated by Room to be able to query the database. <br>
 * SQL-Queries for {@link Article} are defined here.
 *
 * @author Daniel Thoma - daniel.thoma@stud.tu-darmstadt.de
 * @author Simon Schmalfu√ü - simon.schmalfuss@sstud.tu-darmstadt.de
 */
@Dao
public abstract class DaoArticle implements DaoSourceToArticleRelation, DaoArticleToSourceRelation { //NOPMD

    /**
     * Gets the number of {@link Article}s from the {@link Source} with the given uid. <br>
     * Works synchronously.
     *
     * @param uid of the {@link Source} holding the {@link Article}s to be counted.
     * @return the number of {@link Article}s from the {@link Source}, as integer.
     */
    @Query(value = "SELECT COUNT(*) FROM articles WHERE source_id = :uid")
    public abstract int getArticleCountBySourceUidSync(long uid);

    /**
     * Inserts a List of {@link Article}s into the database. <br>
     * Works synchronously.
     *
     * @param articles List of {@link Article}s to be inserted into database.
     * @return long[] Array of uids of the inserted articles. Generated by Room,
     if the uid isn't set in the given {@link Article}.
     */
    @Insert(onConflict = OnConflictStrategy.REPLACE)
    abstract long[] insertAllArticleSync(List<Article> articles);

    /**
     * Updates the given attributes of an {@link Article} identified by its uid. <br>
     * Works synchronously.
     *
     * @param uid to identify the {@link Article} to update.
     * @param imageUrl new image Url.
     * @param publishedDate new published date.
     * @param description new description.
     * @param updated new updated time.
     * @param content new content.
     * @param link new link to the {@link Article} website.
     */
    @Query(value = "UPDATE articles SET image_url = :imageUrl, published_date = :publishedDate,"
        + "description = :description, content = :content, updated = :updated, link = :link "
        + "WHERE uid = :uid")
    abstract void updateOneArticleDataSync(long uid, Uri imageUrl, Date publishedDate,
                                           String description, Date updated, String content, URL link);


    /**
     * Updates the read status of an {@link Article}. <br>
     * Works synchronously.
     *
     * @param uid of the {@link Article} to update.
     * @param read new read status (true, if read, false; if not read).
     */
    @Query("UPDATE articles SET read = :read WHERE :uid = uid")
    public abstract void updateOneArticleReadSync(long uid, boolean read);

    /**
     * Updates the saved status of an {@link Article}. <br>
     * Works synchronously.
     *
     * @param uid of the {@link Article} to update.
     * @param saved new saved status (true, if saved; false, if not saved).
     */
    @Query("UPDATE articles SET saved = :saved WHERE :uid = uid")
    public abstract void updateOneArticleSavedSync(long uid, boolean saved);

    /**
     * Deletes all cached {@link Article}s in the database.
     */
    @Query(value = "DELETE FROM articles")
    public abstract void deleteAllArticleCachedSync();

    /**
     * Deletes all {@link Article}s with a certain {@link Source} uid. <br>
     * Works synchronously.
     *
     * @param uid {@link Source} uid to delete the {@link Article}s from.
     */
    @Query(value = "DELETE FROM articles WHERE source_id = :uid")
    public abstract void deleteAllArticleBySourceUidSync(long uid);

    /**
     * Deletes all {@link Article}s, that are not saved ({@link Article#saved} = false),
     * with a certain {@link Source} uid. <br>
     * Works synchronously.
     *
     * @param uid Source uid to delete unsaved {@link Article}s from.
     */
    @Query(value = "DELETE FROM articles WHERE source_id = :uid AND saved = 0")
    public abstract void deleteAllArticleUnsavedBySourceUidSync(long uid);

    /**
     * Deletes one {@link Article}. <br>
     * Works synchronously.
     *
     * @param article {@link Article} to delete.
     */
    @Delete
    public abstract void deleteOneArticleSync(Article article);

    /**
     * Deletes all cached {@link Article}s older than the given {@link Date}.
     * Goes through all articles. <br>
     * Works synchronously.
     *
     * @param date maximum age of an {@link Article}.
     */
    @Query(value = "DELETE FROM articles WHERE saved = 0 AND updated < :date")
    public abstract void deleteAllArticleUnsavedByAgeSync(Date date);

    /**
     * Returns a subset of the given uids, which exists in the database as {@link Article} uids. <br>
     * Works synchronously.
     *
     * @param uids that should be filtered for the {@link Article} uids.
     * @return existing uids of {@link Article}s form the given list of uids.
     */
    @Query(value = "SELECT uid FROM articles WHERE uid IN (:uids)")
    abstract List<Long> filterForExistingArticleSync(List<Long> uids);


    /**
     * Returns all {@link Article}s from the database. <br>
     * Sets the source reference in the {@link Article}s to the same {@link Source}. <br>
     * Works asynchronously.
     *
     * @return the LiveData of the list of {@link Article}s.
     */
    public LiveData<List<Article>> getAllArticleAsync() {
        return Transformations.map(getAllSourceToArticleAsync(), sourceToArticleRelations -> {
            if (sourceToArticleRelations == null) {
                return null;
            }
            List<Article> articles = new ArrayList<>();

            for (SourceToArticleRelation sourceToArticleRelation : sourceToArticleRelations) {
                sourceToArticleRelation.reference();
                articles.addAll(sourceToArticleRelation.articleList);
            }
            return articles;
        });
    }


    /**
     * Returns the {@link Article} of the given uid. <br>
     * Works asynchronously.
     *
     * @param uid of the {@link Article} to be searched.
     * @return the LiveData of the {@link Article}.
     */
    public LiveData<Article> getOneArticleByArticleUidAsync(long uid) {
        return Transformations.map(getOneArticleToSourceByArticleUidAsync(uid), articleToSource ->
            prepareRelation(articleToSource, uid) ? articleToSource.article : null);
    }

    /**
     * Returns the {@link Article} of the given uid.
     *
     * @param uid Uid of the {@link Article}
     * @return {@link Article}
     */
    public Article getOneArticleByArticleUidSync(long uid) {
        ArticleToSourceRelation relation = getOneArticleToSourceByArticleUidSync(uid);
        if (relation == null) {
            return null;
        }
        relation.reference();
        return relation.article;
    }



    /**
     * Returns all {@link Article} from the database with the given {@link Source} uid. <br>
     * Works asynchronously.
     *
     * @param uid of the {@link Source} to be searched.
     * @return the LiveData of the list of {@link Article}s form the {@link Source}.
     */
    public LiveData<List<Article>> getAllArticleBySourceUidAsync(long uid) {
        return Transformations.map(getOneSourceToArticleBySourceUidAsync(uid), sourceToArticle ->
                prepareRelation(sourceToArticle, uid) ? sourceToArticle.articleList : null);
    }



    /**
     * Inserts a list of {@link Article}s into the database. <br>
     * Sets the uids in the given article list.
     * If the {@link Article} already exists, it will updates it's content. <br>
     * Works synchronously.
     *
     * @param articles list of {@link Article}s to be inserted or updated.
     */
    @Transaction
    public void insertOrUpdateAllArticleSync(List<Article> articles) {
        List<Long> articleUids = new ArrayList<>();

        for (Article article : articles) {
            articleUids.add(article.uid);
        }

        Set<Long> exists = new HashSet<>(filterForExistingArticleSync(articleUids));

        List<Article> toInsert = new ArrayList<>();

        for (Article article : articles) {
            if (exists.contains(article.uid)) {
                updateOneArticleDataSync(article.uid, article.imageUrl, article.publishedDate,
                    article.description, article.updated, article.content, article.link);
            } else {
                toInsert.add(article);
            }
        }

        insertAllArticleSync(toInsert);
    }

    /**
     * If the relation is not null, it will ensure the consistent referencing of the {@link Source}s.
     * Otherwise it logs an error using timber and returns false.
     *
     * @param modelRelation {@link ModelRelation} to prepare the reference.
     * @param uid of an {@link Article} or {@link Source}, used to query for this relation.
     * @return true if the modelRelation is not null, false otherwise.
     */
    private boolean prepareRelation(ModelRelation modelRelation, long uid) {
        if (modelRelation == null) {
            Timber.e("requested relation with id = %d doesn't exist anymore.", uid);
            return false;
        }

        modelRelation.reference();
        return true;
    }

}
